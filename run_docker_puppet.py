import json
import os
import subprocess
from datetime import datetime
from sys import stdout

syscall_filter = [
    "access",
    "chdir",
    "chmod",
    "chown",
    "clone",
    "close",
    "dup",
    "dup2",
    "dup3",
    "execve",
    "fchdir",
    "fchmodat",
    "fchownat",
    "fcntl",
    "fork",
    "getxattr",
    "getcwd",
    "lchown",
    "lgetxattr",
    "lremovexattr",
    "lsetxattr",
    "lstat",
    "link",
    "linkat",
    "mkdir",
    "mkdirat",
    "mknod",
    "open",
    "openat",
    "readlink",
    "readlinkat",
    "removexattr",
    "rename",
    "renameat",
    "rmdir",
    "statfs",
    "symlink",
    "symlinkat",
    "unlink",
    "unlinkat",
    "utime",
    "utimensat",
    "utimes",
    "vfork",
    "write",
    "writev",
]


class SpawnRunPuppet:
    def __init__(self, logger, logger_result_state, logger_result_dependencies, queue_mutation, queue_trace, queue_state, main_lock, target_manifest, oneRun=False):
        self.main_lock = main_lock
        self.logger = logger
        self.target_manifest = target_manifest
        self.queue_mutation = queue_mutation
        self.queue_trace = queue_trace  #contain id of trace
        self.queue_state = queue_state
        self.next_id = len(os.listdir("output")) + 1
        self.existing_ids = set()
        self.output_dir = "output/"+target_manifest+"_" + datetime.now().strftime('%Y-%m-%d_%H-%M-%S') + "/"
        os.makedirs(os.path.join(os.getcwd(), self.output_dir))
        self.current_id = 0
        self.init_image()
        self.oneRun = oneRun

        manifs_f = open('availible_manifest_param.json')
        data = json.load(manifs_f)
        self.manifest_content = data[target_manifest]["manifest_content"]
        self.module_name = data[target_manifest]["module_name"]
        self.module_version = data[target_manifest]["version"]
        self.logger_result_state = logger_result_state
        self.logger_result_dependencies = logger_result_dependencies

    def init_image(self):
        #self.logger.info("Pulling puppetserver image")
        with open("output/SpawnRunPuppet.log", "a") as output:
            # TODO add the remove and execute the command to use the docker-file to install the module one time
            subprocess.call("docker pull puppet/puppetserver", shell=True, stdout=output, stderr=output)


    def get_target_catalog(self):
        print("--------------------------------getting target catalog--------------------------------")
        id_of_catalog = -1
        self.run_puppet_manifest_from_name([], id_of_catalog, [])
        search_dir = self.output_dir + str(id_of_catalog)+"/"
        if not os.path.exists(search_dir + "puppet_catalog.json"):
            print("no puppet_catalog.log the manifest failed to run and the catalog wasn't generated by puppet")
            raise SystemExit(1)
        with open(search_dir+"puppet_catalog.json") as json_file:
            json_file.readline()
            catalog_json = json.load(json_file)
        #self.current_id += 1
        print("--------------------------------getting target catalog finish--------------------------------")
        return (self.target_manifest, catalog_json)

    def process_mutation_queue(self):
        self.logger.info("spawn_run_puppet : processing started")
        while True:
            mutations = self.queue_mutation.get()  # every mutation is a sequence of operation to be applied together before running the puppet manifest on the fresh image
            print("process_mutation_queue")
            self.process_mutation(mutations)
            if self.oneRun:
                break

    '''
    Given a list of mutation compute their linux terminal command equivalent then give it to the docker handler for processing, a new id is gennerated to track/uniquely identify the result though the pipeline 
    '''
    def process_mutation(self, mutations: list):
        #eg: ("rename", "path_file", "new_name") Current version
        #eg: ("edit_append", "path_file", "new_content") Future version
        #eg: ("edit_prepend", "path_file", "new_content") Future version
        #eg: ("replace", "path_file", "new_content") Future version
        #eg: ("delete", "path_file or dir", "new_name") Current version
        #eg: ("create", "path"+"new_name") Current version

        mutations_commands = []
        mutations = mutations[1]
        for mut in mutations:
            match mut[0]:
                case "rename":
                    mutations_commands.append("mv "+mut[1]+" "+'/'.join(mut[1].split("/")[:-1])+mut[2])
                case "delete":
                    mutations_commands.append("rm -rf "+mut[1])
                case "create":
                    mutations_commands.append("touch "+mut[1])
                case _:
                    raise NotImplemented


        success = self.run_puppet_manifest_from_name(mutations_commands, self.current_id, mutations)
        local_output_dir = self.output_dir + str(self.current_id)
        self.queue_trace.put((self.current_id, local_output_dir, self.target_manifest))
        self.queue_state.put((self.current_id, local_output_dir))
        self.current_id += 1


    '''
    Given the list of command mutation to apply before the manifest, compute the required command and run them on the puppet_server image 
    a. start fresh puppet_server image
    b) The following command are prefixed by docker exec -i puppetserver to open a shell and execute them on the docker image itself
    b. create the directory for the result
    b. override default manifest with the one we wish to test
    b. pull/install the module targeted by the testing
    b. apply the mutation 
    b. run the manifest with strace filtering a subset of syscall 
    b. save the catalog
    b. save the output of the tree command 
    a. shutdown the puppet_server image
    '''
    def run_puppet_manifest_from_name(self, mutations_commands, processing_id, mutations):
        local_output_dir = self.output_dir + str(processing_id) + "/"
        os.makedirs(os.path.join(os.getcwd(), local_output_dir))
        with open(local_output_dir + "terminal.log", "a") as output:
            commands = []
            commands.append("docker-compose up -d")
            command_docker_shell = "docker exec -i puppetserver "
            commands.append(command_docker_shell + "mkdir "+local_output_dir)
            commands.append(command_docker_shell + "bash -c  \"echo " + self.manifest_content + " > /etc/puppetlabs/code/environments/production/manifests/init.pp\"")  #echo "include 'docker'" / etc / puppetlabs / code / environments / production / manifests / init.pp
            commands.append(command_docker_shell + "puppet module install " + self.module_name +" --version="+self.module_version)
            commands += [command_docker_shell + "bash -c \"" + mut + "\"" for mut in mutations_commands]
            commands.append((command_docker_shell +
                         "strace"
                         " -s 300"
                         " -o /"+local_output_dir + "/strace_output.txt" +
                         " -e " + ','.join(syscall_filter) +  #-e trace=open,openat,close,read,write,connect,accept
                         " -f " +  # -f = follow forked childs -y display file name
                         (
                                 " puppet apply " +
                                 "/etc/puppetlabs/code/environments/production/manifests/init.pp" +
                                 " --debug --evaltrace"
                         )))  #puppet apply /etc/puppetlabs/code/environments/production/manifests/init.pp --debug --evaltrace
            commands.append(command_docker_shell + "bash -c \"puppet catalog find > /"+local_output_dir + "/puppet_catalog.json\"")

            commands.append(command_docker_shell + "bash -c \"tree > /"+local_output_dir + "/state.txt\"")

            commands.append("docker-compose down")

            # execute all of the above command
            for command in commands:
                print("SpawnRunPuppet: " + command)
                subprocess.call(command, shell=True, stdout=output, stderr=output)
