import os


class StateChecker:
    def __init__(self, logger, logger_result, queue_state, main_lock, puppet_manifest, args, oneRun=False):
        self.main_lock = main_lock
        self.logger = logger
        self.puppet_manifest = puppet_manifest
        self.args = args
        self.queue_state = queue_state
        self.state_accumulator = []
        self.oneRun = oneRun
        self.logger_result = logger_result

    def process_state_queue(self):
        self.logger.info("spawn_run_puppet : processing started")
        while True:
            state = self.queue_state.get() #every mutation is a sequence of operation to be applied together before running the puppet manifest on the fresh image
            print("process_state_queue")
            self.process_state(state)
            if self.oneRun:
                break


    def process_state(self, state_info):
        #TODO compare state with past states
        differences = [] # each list in this list corresponds to differences between states for each saved state

        if not os.path.exists(state_info[1] + "/state.txt"): # The manifest failed to run so no need to test the state reconciliation
            self.logger_result.info("Run of puppet manifest crash with mutation : ")#%s" % (str(mutations)))
            return

        state = self.convert_to_state_graph(state_info[1])
        
        if len(self.state_accumulator) > 0:
            differences.append(self.compare_states(state, self.state_accumulator[0]))

        self.state_accumulator.append(state)

        self.logger_result.info("state differences " + str(state_info[0]) + ": " + str(differences))

    def compare_states(self, state1, state2):
        both_have = [] # both have these edges
        only_first = [] # only first state has these edges 
        for i in state1:
            if i in state2:
                both_have.append(i)
            else:
                only_first.append(i)
        return only_first

    def convert_to_state_graph(self, state_dir):
        original_dir = "main_dir" # this is for a top node, so that we have a tree starting from one root.
        with open(state_dir + "/state.txt", "r") as f:
            state = f.readlines()
        directory = []
        for i in state:
            temp = i.split("--") # since that separates the tree from the files/directory names
            directory.append(temp)
        directory = directory[1:-2]
        edges = [] # here we save the edges from directrys to files, so that we later can check for reconciliation
        queue = [] # for keeping track in what directory we are
        curr_count = 0
        queue.append(original_dir)

        # goes through the file generated by the tree command and then compiles the edges to files
        no_save = False
        where_is = 0
        filetypes_list = ["txt", "java", "py", "cs", "php", "swift", "vb", "jar", "c", "xml", "csv", "dat", "db", "dbf", "log", "mdb", "sav", "sql", "tar", "bat", "bin", "exe", "msi", "sh", "wsf", "aif", "cda", "mid", "mp3", "mpa", "ogg", "wav", "wma", "h"]
        filetypes = {}
        for i in filetypes_list:
            filetypes[i] = 0
        for i in directory:
            queue.append(i[-1][1:-1])
            if (len(i[0])-1)//4+1 <= curr_count:
                for j in range(curr_count-(len(i[0])-1)//4):
                    queue.pop(len(queue)-2)
            if (no_save == False or len(queue) <= where_is) and (queue[-1] == "puppetlabs" or queue[-1] == "puppetserver" or queue[-1] == "available_manifests" or queue[-1] == "modules" or queue[-1] == "output" or queue[-1] == "puppetserver_conf"): # puppetserver directory will have changing names each run since that is how puppet works and there are mounted directories which are local so can change
                no_save = True
                where_is = len(queue)
            elif len(queue) <= where_is:
                no_save = False
            if " -> " not in queue[-1] and "." in queue[-1] and no_save == False and queue[-2][:5] != "jruby": # to only keep files as endpoints, jruby will have some changing numbers in names, because of puppet
                q2 = queue[-1].split(".")[-1]
                if q2 in filetypes: # we filter for filetypes we want to find
                    edges.append([queue[-2],queue[-1]])
            curr_count =(len(i[0])-1)//4+1
        return edges
